"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertToInferred = void 0;
const devkit_1 = require("@nx/devkit");
const plugin_1 = require("../../plugins/plugin");
const executor_to_plugin_migrator_1 = require("@nx/devkit/src/generators/plugin-migrations/executor-to-plugin-migrator");
const target_options_map_1 = require("./lib/target-options-map");
const utils_1 = require("nx/src/tasks-runner/utils");
const plugin_migration_utils_1 = require("@nx/devkit/src/generators/plugin-migrations/plugin-migration-utils");
async function convertToInferred(tree, options) {
    const projectGraph = await (0, devkit_1.createProjectGraphAsync)();
    const migratedProjects = await (0, executor_to_plugin_migrator_1.migrateProjectExecutorsToPlugin)(tree, projectGraph, '@nx/eslint/plugin', plugin_1.createNodesV2, { targetName: 'lint' }, [
        {
            executors: ['@nx/eslint:lint', '@nrwl/linter:eslint'],
            postTargetTransformer,
            targetPluginOptionMapper: (targetName) => ({ targetName }),
        },
    ], options.project);
    if (migratedProjects.size === 0) {
        throw new Error('Could not find any targets to migrate.');
    }
    if (!options.skipFormat) {
        await (0, devkit_1.formatFiles)(tree);
    }
}
exports.convertToInferred = convertToInferred;
function postTargetTransformer(target, tree, projectDetails, inferredTargetConfiguration) {
    if (target.inputs) {
        const inputs = target.inputs.filter((input) => typeof input === 'string' &&
            ![
                'default',
                '{workspaceRoot}/.eslintrc.json',
                '{workspaceRoot}/.eslintignore',
                '{workspaceRoot}/eslint.config.js',
            ].includes(input));
        if (inputs.length === 0) {
            delete target.inputs;
        }
    }
    if (target.options) {
        handlePropertiesInOptions(target.options, projectDetails, target);
    }
    if (target.configurations) {
        for (const configurationName in target.configurations) {
            const configuration = target.configurations[configurationName];
            handlePropertiesInOptions(configuration, projectDetails, target);
        }
        if (Object.keys(target.configurations).length !== 0) {
            for (const configuration in target.configurations) {
                if (Object.keys(target.configurations[configuration]).length === 0) {
                    delete target.configurations[configuration];
                }
            }
            if (Object.keys(target.configurations).length === 0) {
                delete target.configurations;
            }
        }
    }
    if (target.outputs) {
        (0, plugin_migration_utils_1.processTargetOutputs)(target, [], inferredTargetConfiguration, {
            projectName: projectDetails.projectName,
            projectRoot: projectDetails.root,
        });
    }
    return target;
}
function handlePropertiesInOptions(options, projectDetails, target) {
    if ('eslintConfig' in options) {
        options.config = (0, plugin_migration_utils_1.toProjectRelativePath)(options.eslintConfig, projectDetails.root);
        delete options.eslintConfig;
    }
    if ('force' in options) {
        delete options.force;
    }
    if ('silent' in options) {
        delete options.silent;
    }
    if ('hasTypeAwareRules' in options) {
        delete options.hasTypeAwareRules;
    }
    if ('errorOnUnmatchedPattern' in options) {
        if (!options.errorOnUnmatchedPattern) {
            options['no-error-on-unmatched-pattern'] = true;
        }
        delete options.errorOnUnmatchedPattern;
    }
    if ('outputFile' in options) {
        target.outputs ??= [];
        target.outputs.push(options.outputFile);
    }
    for (const key in target_options_map_1.targetOptionsToCliMap) {
        if (options[key]) {
            const prevValue = options[key];
            delete options[key];
            options[target_options_map_1.targetOptionsToCliMap[key]] = prevValue;
        }
    }
    if ('lintFilePatterns' in options) {
        const normalizedLintFilePatterns = options.lintFilePatterns.map((pattern) => {
            return (0, utils_1.interpolate)(pattern, {
                workspaceRoot: '',
                projectRoot: projectDetails.root,
                projectName: projectDetails.projectName,
            });
        });
        options.args = normalizedLintFilePatterns.map((pattern) => pattern.startsWith(projectDetails.root)
            ? pattern.replace(new RegExp(`^${projectDetails.root}/`), './')
            : pattern);
        delete options.lintFilePatterns;
    }
}
exports.default = convertToInferred;
